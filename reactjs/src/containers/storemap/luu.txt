import React, { useState, useEffect } from 'react';
import axios from 'axios';
import {
  MapContainer,
  TileLayer,
  Marker,
  Popup,
  Polyline,
  useMap,
} from 'react-leaflet';
import 'leaflet/dist/leaflet.css';
import L from 'leaflet';
import polyline from '@mapbox/polyline'; // Th√™m th∆∞ vi·ªán gi·∫£i m√£ polyline
import styles from '../css/storemap/storemap.module.css';
// S·ª≠a l·ªói icon m·∫∑c ƒë·ªãnh c·ªßa Leaflet
delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png',
  iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
  shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
});

const StoreMap = () => {
  const [stores, setStores] = useState([]);
  const [userLocation, setUserLocation] = useState(null);
  const [routeCoordinates, setRouteCoordinates] = useState([]);
  const [inputLocation, setInputLocation] = useState('');
  const [isLoading, setIsLoading] = useState(true);

  // L·∫•y danh s√°ch c·ª≠a h√†ng t·ª´ API
  useEffect(() => {
    const fetchStores = async () => {
      try {
        const res = await axios.get('http://localhost:3000/api/v1/liststore');
        if (res.data.errCode === 0) {
          setStores(res.data.data);
        } else {
          console.error('L·ªói API:', res.data.message);
        }
      } catch (err) {
        console.error('L·ªói khi l·∫•y danh s√°ch c·ª≠a h√†ng:', err);
        alert('Kh√¥ng th·ªÉ t·∫£i danh s√°ch c·ª≠a h√†ng.');
      } finally {
        setIsLoading(false);
      }
    };
    fetchStores();
  }, []);

  const getNearestStore = (userLat, userLng) => {
    let nearest = null;
    let minDist = Infinity;
    stores.forEach((store) => {
      const dist = Math.sqrt(
        Math.pow(store.latitude - userLat, 2) + Math.pow(store.longitude - userLng, 2)
      );
      if (dist < minDist) {
        minDist = dist;
        nearest = store;
      }
    });
    return nearest;
  };

  const handleUserLocation = () => {
    navigator.geolocation.getCurrentPosition(
      async (position) => {
        const { latitude, longitude } = position.coords;
        setUserLocation([latitude, longitude]);
        await drawRoute(latitude, longitude);
      },
      (err) => {
        console.error('L·ªói khi l·∫•y v·ªã tr√≠:', err);
        alert('Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠ hi·ªán t·∫°i. Vui l√≤ng nh·∫≠p v·ªã tr√≠ th·ªß c√¥ng.');
      }
    );
  };

  const geocodeLocation = async () => {
    if (!inputLocation) {
      alert('Vui l√≤ng nh·∫≠p v·ªã tr√≠.');
      return;
    }
    try {
      const res = await axios.get(
        `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(inputLocation)}&format=json`
      );
      if (res.data && res.data.length > 0) {
        const { lat, lon } = res.data[0];
        const parsedLat = parseFloat(lat);
        const parsedLon = parseFloat(lon);
        setUserLocation([parsedLat, parsedLon]);
        await drawRoute(parsedLat, parsedLon);
      } else {
        alert('Kh√¥ng t√¨m th·∫•y v·ªã tr√≠ b·∫°n nh·∫≠p.');
      }
    } catch (err) {
      console.error('L·ªói khi t√¨m v·ªã tr√≠:', err);
      alert('L·ªói khi t√¨m v·ªã tr√≠. Vui l√≤ng th·ª≠ l·∫°i.');
    }
  };

  const drawRoute = async (lat, lng) => {
    const nearestStore = getNearestStore(lat, lng);
    if (!nearestStore) {
      alert('Kh√¥ng t√¨m th·∫•y c·ª≠a h√†ng n√†o g·∫ßn v·ªã tr√≠ n√†y.');
      return;
    }

    const directionsUrl = 'https://api.openrouteservice.org/v2/directions/driving-car';
    const body = {
      coordinates: [[lng, lat], [nearestStore.longitude, nearestStore.latitude]],
    };

    try {
      const res = await axios.post(directionsUrl, body, {
        headers: {
          Authorization: '5b3ce3597851110001cf6248410fa96dbf134b59b64e995b9536503e',
          'Content-Type': 'application/json; charset=utf-8',
          Accept: 'application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8',
        },
      });

      // Ghi log ph·∫£n h·ªìi ƒë·ªÉ ki·ªÉm tra
      console.log('Ph·∫£n h·ªìi t·ª´ OpenRouteService:', res.data);

      if (res.data && res.data.routes && res.data.routes.length > 0) {
        const geometry = res.data.routes[0].geometry;
        if (typeof geometry === 'string') {
          // Gi·∫£i m√£ chu·ªói polyline th√†nh m·∫£ng t·ªça ƒë·ªô [lat, lng]
          const decodedCoords = polyline.decode(geometry);
          // Chuy·ªÉn ƒë·ªïi sang ƒë·ªãnh d·∫°ng [lat, lng] cho Leaflet
          const coords = decodedCoords.map(([lat, lng]) => [lat, lng]);
          setRouteCoordinates(coords);
        } else {
          alert('D·ªØ li·ªáu tuy·∫øn ƒë∆∞·ªùng kh√¥ng h·ª£p l·ªá: Geometry kh√¥ng ph·∫£i chu·ªói polyline.');
        }
      } else {
        alert('Kh√¥ng t√¨m th·∫•y tuy·∫øn ƒë∆∞·ªùng. Vui l√≤ng ki·ªÉm tra t·ªça ƒë·ªô ho·∫∑c API key.');
      }
    } catch (err) {
      console.error('L·ªói khi v·∫Ω tuy·∫øn ƒë∆∞·ªùng:', err);
      alert('L·ªói khi k·∫øt n·ªëi OpenRouteService: ' + (err.response?.data?.error?.message || err.message));
    }
  };

  // Component ƒë·ªÉ ƒëi·ªÅu ch·ªânh khung nh√¨n b·∫£n ƒë·ªì
  const MapController = () => {
    const map = useMap();
    useEffect(() => {
      if (stores.length > 0) {
        const bounds = L.latLngBounds(stores.map((store) => [store.latitude, store.longitude]));
        map.fitBounds(bounds);
      }
      if (userLocation) {
        map.setView(userLocation, 16);
      }
    }, [stores, userLocation, map]);
    return null;
  };

  return (
    <div className={styles.container}>
      <div className={styles.sidebar}>
        <h2>üõçÔ∏è Danh s√°ch c·ª≠a h√†ng</h2>
        <div className={styles.inputGroup}>
          <input
            type="text"
            value={inputLocation}
            onChange={(e) => setInputLocation(e.target.value)}
            placeholder="Nh·∫≠p v·ªã tr√≠ c·ªßa b·∫°n..."
          />
          <button onClick={geocodeLocation}>üîç T√¨m ƒë∆∞·ªùng</button>
        </div>
        <button onClick={handleUserLocation}>üìç D√πng v·ªã tr√≠ hi·ªán t·∫°i</button>
        {isLoading ? (
          <p>ƒêang t·∫£i...</p>
        ) : (
          <ul className={styles.storeList}>
            {stores.length > 0 ? (
              stores.map((store) => (
                <li
                  key={store.store_id}
                  onClick={() => {
                    setUserLocation([store.latitude, store.longitude]);
                  }}
                >
                  <b>{store.name}</b>
                  <br />
                  {store.address}
                  <br />
                  Gi·ªù m·ªü: {store.open_hours} - {store.close_hour}
                </li>
              ))
            ) : (
              <p>Kh√¥ng c√≥ c·ª≠a h√†ng n√†o.</p>
            )}
          </ul>
        )}
      </div>
      <MapContainer
        center={[10.0478, 105.769]}
        zoom={13}
        style={{ height: '600px', width: '100%' }}
        className={styles.map}
      >
        <TileLayer
          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
          attribution="¬© OpenStreetMap contributors"
        />
        <MapController />
        {stores.map((store) => (
          <Marker key={store.store_id} position={[store.latitude, store.longitude]}>
            <Popup>
              <b>{store.name}</b>
              <br />
              {store.address}
              <br />
              Gi·ªù m·ªü: {store.open_hours} - {store.close_hour}
            </Popup>
          </Marker>
        ))}
        {userLocation && (
          <Marker position={userLocation}>
            <Popup>V·ªã tr√≠ c·ªßa b·∫°n</Popup>
          </Marker>
        )}
        {routeCoordinates.length > 0 && (
          <Polyline positions={routeCoordinates} color="blue" />
        )}
      </MapContainer>
    </div>
  );
};

export default StoreMap;